package com.storedobject.core;

import com.storedobject.common.DateUtility;
import com.storedobject.core.annotation.Column;
import com.storedobject.job.MessageGroup;

import java.sql.Timestamp;

public class LoginMessage extends StoredObject {

    private static final String[] priorityValues = new String[] {
    	"Normal",
        "Low",
        "Medium",
        "High",
    };
    private int priority = 0;
    private String message;
    private boolean active = true;
    private Timestamp validFrom = DateUtility.now();
    private Timestamp validTo = DateUtility.addDay(validFrom, 30);
    private boolean disableLogin = false;
    private boolean loginAlert = false;
    private boolean showEveryTime = false;
	private StoredObject generatedBy;

    public LoginMessage() {
    }

    public static void columns(Columns columns) {
        columns.add("Message", "text");
        columns.add("Active", "boolean");
        columns.add("ValidFrom", "timestamp");
        columns.add("ValidTo", "timestamp");
        columns.add("LoginAlert", "boolean");
        columns.add("DisableLogin", "boolean");
        columns.add("ShowEveryTime", "boolean");
        columns.add("Priority", "int");
    }

    public static String[] links() {
        return new String[] {
            "Groups|com.storedobject.core.SystemUserGroup||",
            "Users|com.storedobject.core.SystemUser||",
            "Read by|com.storedobject.core.SystemUser/1||",
            "Processor|com.storedobject.core.Logic||",
            "Generated by|com.storedobject.core.StoredObject/5/Any||",
            "Escalated Messages|com.storedobject.core.LoginMessage||",
        };
    }

    public void setMessage(String message) {
        this.message = message;
    }

    @Column(style = "(large)")
    public String getMessage() {
        return message;
    }

    public void setActive(boolean active) {
        this.active = active;
    }

    public boolean getActive() {
        return active;
    }

    public void setValidFrom(Timestamp validFrom) {
        this.validFrom = new Timestamp(validFrom.getTime());
    }

    public Timestamp getValidFrom() {
        return new Timestamp(validFrom.getTime());
    }

    public void setValidTo(Timestamp validTo) {
        this.validTo = new Timestamp(validTo.getTime());
    }

    public Timestamp getValidTo() {
        return new Timestamp(validTo.getTime());
    }

    public void setLoginAlert(boolean loginAlert) {
        this.loginAlert = loginAlert;
    }

    public boolean getLoginAlert() {
        return loginAlert;
    }

    public void setDisableLogin(boolean disableLogin) {
        this.disableLogin = disableLogin;
    }

    public boolean getDisableLogin() {
        return disableLogin;
    }

    public void setShowEveryTime(boolean showEveryTime) {
        this.showEveryTime = showEveryTime;
    }

    public boolean getShowEveryTime() {
        return showEveryTime;
    }

    public void setPriority(int priority) {
        this.priority = priority;
    }

    public int getPriority() {
        return priority;
    }

    public static String[] getPriorityValues() {
        return priorityValues;
    }

    public static String getPriorityValue(int value) {
        String[] s = getPriorityValues();
        return s[value % s.length];
    }

    public String getPriorityValue() {
        return getPriorityValue(priority);
    }
    
    @Override
	public void validateData(TransactionManager tm) throws Exception {
        if(StringUtility.isWhite(message)) {
            throw new Invalid_Value("Message");
        }
        super.validateData(tm);
    }
    
    public void setProcessorLogic(TransactionManager tm, Class<?> processorClass) throws Exception {
    	tm.transact(t -> setProcessorLogic(t, processorClass));
    }

    public void setProcessorLogic(Transaction transaction, Class<?> processorClass) throws Exception {
    	String cn = processorClass.getName();
    	Logic logic = get(transaction, Logic.class, "ClassName='" + cn + "'");
    	if(logic == null) {
    		logic = new Logic(cn, "Processor");
    		logic.save(transaction);
    	}
    	addLink(transaction, logic);
    }

    public Logic getProcessorLogic() {
    	Logic logic = listLinks(Logic.class).findFirst();
		if(logic == null) {
			if(getGeneratedBy() != null) {
				ApplicationAlertHandler aah = get(ApplicationAlertHandler.class, "DataClassName='"
						+ generatedBy.getClass().getName() + "'");
				if(aah != null) {
					logic = new Logic(aah.getLogicClassName(), "Processor");
					logic.makeVirtual();
				}
			}
		}
		return logic;
    }
    
    public void setGeneratedBy(TransactionManager tm, StoredObject generatedBy) throws Exception {
    	tm.transact(t -> setGeneratedBy(t, generatedBy));
    }

    public void setGeneratedBy(Transaction transaction, StoredObject generatedBy) throws Exception {
		if(generatedBy != null) {
			addLink(transaction, generatedBy, 5);
			this.generatedBy = null;
		}
    }

	public StoredObject getGeneratedBy() {
		if(generatedBy == null) {
			generatedBy = listGeneratedBy().findFirst();
		}
		return generatedBy;
	}
    
    public ObjectIterator<StoredObject> listGeneratedBy() {
    	return listLinks(5, StoredObject.class, true);
    }
	
	public static ObjectIterator<LoginMessage> listMine(StoredObject generatedBy) {
		return generatedBy.listMasters(9, LoginMessage.class);
	}
	
	public boolean isReadBy(SystemUser user) {
		return isReadOrSent(user, false);
	}
	
	public boolean isReadBy(Person person) {
		if(person == null) {
			return true;
		}
		return isReadBy(person.getId());
	}

	public boolean isReadBy(PersonRole personRole) {
		if(personRole == null) {
			return true;
		}
		return isReadBy(personRole.getPersonId(), false);
	}
    
	public boolean isReadBy(Id personId) {
		return isReadBy(personId, true);
	}
	
	public boolean isSentBy(SystemUser user) {
		return isReadOrSent(user, true) || isReadOrSent(user, false);
	}
	
	public boolean isSentBy(Person person) {
		if(person == null) {
			return true;
		}
		return isSentBy(person.getId());
	}

	public boolean isSentBy(PersonRole personRole) {
		if(personRole == null) {
			return true;
		}
		return isSentBy(personRole.getPersonId(), false);
	}
    
	public boolean isSentBy(Id personId) {
		return isSentBy(personId, true);
	}
	
	private boolean isSentBy(Id personId, boolean ambiguous) {
		return isReadOrSent(personId, ambiguous, true);
	}
	
	private boolean isReadBy(Id personId, boolean ambiguous) {
		return isReadOrSent(personId, ambiguous, false);
	}
	
	private boolean isReadOrSent(SystemUser user, boolean sent) {
		if(user == null) {
			return true;
		}
		return existsLink(sent ? 0 : 1, user);
	}
	
	private boolean isReadOrSent(Id personId, boolean ambiguous, boolean sent) {
		if(personId == null) {
			return true;
		}
		ObjectIterator<SystemUser> sus = list(SystemUser.class, "Person=" + personId);
		boolean found = false;
		for(SystemUser su: sus) {
			found = true;
			if(isReadOrSent(su, sent)) {
				sus.close();
				return true;
			}
		}
		if(ambiguous && !found) {
			SystemUser su = get(SystemUser.class, "Id=" + personId);
			if(su != null) {
				return isReadOrSent(su, sent);
			} else {
				if(!sent) {
					return isReadBy(get(PersonRole.class, "Id=" + personId, true));
				}
			}
		}
		return false;
	}

	public static boolean showLoginMessages(MessageViewer viewer) {
		boolean blocked = false;
    	int messages = 0;
    	try {
    		String c = " AND Active AND '" + Database.format(DateUtility.now()) + "' BETWEEN ValidFrom AND ValidTo";
    		LoginMessage lm = get(LoginMessage.class, "DisableLogin" + c);
    		if(lm != null) {
    			blocked = true;
    			if(viewer != null) {
    				viewer.alert(lm.getMessage());
    			}
    			return true;
    		}
    		for(LoginMessage m: StoredObject.list(LoginMessage.class, "LoginAlert" + c)) {
    			messages++;
    			if(viewer != null) {
    				viewer.alert(m.getMessage());
    			}
    		}
    	} catch(Throwable ignored) {
    	}
    	if(messages == 0 || viewer == null) {
    		return blocked;
    	}
    	return false;
    }
    
    private static void sanitize(TransactionControl tc, SystemUser su) {
    	for(SystemUserGroup g: su.listLinks(SystemUserGroup.class)) {
        	for(LoginMessage m: g.listMasters(LoginMessage.class)) {
    			for(SystemUser u: g.listMasters(SystemUser.class)) {
    				tc.addLink(m, u);
    			}
    			tc.removeLink(m, g);
        	}    		
    	}
    	tc.commit();
    }

    public static void showMessages(ApplicationServer server, Id minId) {
    	MessageViewer viewer = server.getDevice().getMessageViewer();
    	if(viewer == null) {
    		return;
    	}
		try {
			TransactionManager tm = viewer.getTransactionManager();
			TransactionControl tc = new TransactionControl(viewer.getTransactionManager());
			SystemUser su = tm.getUser();
			sanitize(tc, su);
			String now = "'" + Database.format(DateUtility.now()) + "'";
			String c =  "Active AND " + now + " BETWEEN ValidFrom AND ValidTo";
			if(!Id.isNull(minId)) {
				c += " AND T.Id>" + minId;
			}
			su.listMasters(0, LoginMessage.class, c, "Priority DESC").forEach(viewer::message);
			for(LoginMessage lm: list(LoginMessage.class, "ValidTo<" + now)) {
				tc.delete(lm);
			}
			tc.commit();
		} catch(Throwable ignore) {
		}
    }

	public static LoginMessage alert(Transaction transaction, String message, StoredObject person) throws Exception {
		return alert(transaction, message, ObjectIterator.create(person), null, null);
	}

	public static LoginMessage alert(Transaction transaction, String message, StoredObject person, StoredObject generatedBy) throws Exception {
		return alert(transaction, message, ObjectIterator.create(person), null, generatedBy);
	}

	public static LoginMessage alert(Transaction transaction, String message, StoredObject person,
		Class<?> processorClass) throws Exception {
		return alert(transaction, message, ObjectIterator.create(person), processorClass, null);
	}

	public static LoginMessage alert(Transaction transaction, String message, StoredObject person,
		Class<?> processorClass, StoredObject generatedBy) throws Exception {
		return alert(transaction, message, ObjectIterator.create(person), processorClass, generatedBy);
	}

	public static LoginMessage alert(Transaction transaction, String message, Iterable<? extends StoredObject> persons) throws Exception {
		return alert(transaction, message, persons, null, null);
	}
	
	public static LoginMessage alert(Transaction transaction, String message, Iterable<? extends StoredObject> persons,
		Class<?> processorClass) throws Exception {
		return alert(transaction, message, persons, processorClass, null);
	}

	public static LoginMessage alert(Transaction transaction, String message, Iterable<? extends StoredObject> persons,
			Class<?> processorClass, StoredObject generatedBy) throws Exception {
		return alert(transaction, message, persons, processorClass, generatedBy, 30);
	}
	
	public static LoginMessage alert(Transaction transaction, String message, StoredObject person, int validityInDays) throws Exception {
		return alert(transaction, message, ObjectIterator.create(person), null, null, validityInDays);
	}

	public static LoginMessage alert(Transaction transaction, String message, StoredObject person,
		StoredObject generatedBy, int validityInDays) throws Exception {
		return alert(transaction, message, ObjectIterator.create(person), null, generatedBy, validityInDays);
	}

	public static LoginMessage alert(Transaction transaction, String message, StoredObject person,
		Class<?> processorClass, int validityInDays) throws Exception {
		return alert(transaction, message, ObjectIterator.create(person), processorClass, null, validityInDays);
	}

	public static LoginMessage alert(Transaction transaction, String message, StoredObject person,
		Class<?> processorClass, StoredObject generatedBy, int validityInDays) throws Exception {
		return alert(transaction, message, ObjectIterator.create(person), processorClass, generatedBy, validityInDays);
	}

	public static LoginMessage alert(Transaction transaction, String message, Iterable<? extends StoredObject> persons,
									 int validityInDays) throws Exception {
		return alert(transaction, message, persons, null, null, validityInDays);
	}
	
	public static LoginMessage alert(Transaction transaction, String message, Iterable<? extends StoredObject> persons,
		Class<?> processorClass, int validityInDays) throws Exception {
		return alert(transaction, message, persons, processorClass, null, validityInDays);
	}

	public static LoginMessage alert(Transaction transaction, String message, Iterable<? extends StoredObject> persons,
			StoredObject generatedBy, int validityInDays) throws Exception {
		return alert(transaction, message, persons, null, generatedBy, validityInDays);
	}
	
	public static LoginMessage alert(Transaction transaction, String message, Iterable<? extends StoredObject> persons,
			Class<?> processorClass, StoredObject generatedBy, int validityInDays) throws Exception {
		LoginMessage m = new LoginMessage();
		m.setValidTo(DateUtility.addDay(m.validFrom, validityInDays));
		m.setMessage(message);
		m.save(transaction);
		m.addPersons(transaction, persons);
		if(processorClass != null) {
			m.setProcessorLogic(transaction, processorClass);
		}
		if(generatedBy != null) {
			m.setGeneratedBy(transaction, generatedBy);
		}
		return m;
	}
	
	@Override
	public void validateDelete() throws Exception {
		Transaction t = getTransaction();
		try(ObjectIterator<LoginMessage> managers = listLinks(LoginMessage.class)) {
			for(LoginMessage m: managers) {
				if(!t.isInvolved(m)) {
					m.delete(t);
				}
			}
		}
		try(ObjectIterator<LoginMessage> managers = listMasters(LoginMessage.class)) {
			for(LoginMessage m: managers) {
				if(!t.isInvolved(m)) {
					m.delete(t);
				}
			}
		}
		super.validateDelete();
	}
	
	public LoginMessage escalate(TransactionControl transactionControl, Iterable<? extends StoredObject> persons, int days) {
		LoginMessage m;
		try {
			m = (LoginMessage) copy();
		} catch (Exception e) {
			return null;
		}
		m.setValidFrom(DateUtility.addDay(validFrom, days));
		m.setValidTo(DateUtility.addDay(validTo, days));
		try {
			m.addPersons(transactionControl.getTransaction(), persons);
		} catch (Exception e) {
			transactionControl.rollback();
			return null;
		}
		if(transactionControl.save(m) && transactionControl.addLink(this, m)) {
			return m;
		}
		return null;
	}
	
	void addPersons(Transaction transaction, Iterable<? extends StoredObject> persons) throws Exception{
		SystemUser su;
		for(StoredObject so: persons) {
			su = su(so);
			if(su != null) {
				addLink(transaction, su);
				continue;
			}
			if(so instanceof SystemUserGroup) {
				addLink(transaction, so);
			} else if(so instanceof MessageGroup mg) {
				for(SystemUser u: mg.listUsers()) {
					u = su(u);
					if(u != null) {
						addLink(transaction, u);
					}
				}
			}
		}
	}
	
	private static SystemUser su(StoredObject so) {
		if(so instanceof SystemUser su) {
			if((su.getStatus() & 0b110) > 0) { // Eliminate system/process users
				return null;
			}
			return (SystemUser)so;
		}
		if(so instanceof Person) {
			return su(so.getId());
		}
		if(so instanceof PersonRole) {
			return su(((PersonRole)so).getPersonId());
		}
		if(so instanceof Contact) {
			Person p = so.getMaster(Person.class);
			if(p != null) {
				return su(p);
			}
			PersonRole r = so.getMaster(PersonRole.class, true);
			if(r != null) {
				return su(r);
			}
		}
		return null;
	}
	
	private static SystemUser su(Id pid) {
		return get(SystemUser.class, "Person=" + pid);
	}
	
	public boolean markAsRead(TransactionManager tm) {
		return markAsRead(tm, false);
	}
	
	public boolean markAsRead(TransactionManager tm, boolean doNotDelete) {
		SystemUser su = tm.getUser();
		if(!(existsLink(1, su) && !existsLink(su))) {
			try {
				tm.transact(t -> { removeLink(t, su); addLink(t, su, 1); });
			} catch (Exception e) {
				return false;
			}
		}
		if(doNotDelete) {
			return true;
		}
		if(!existsLinks(0, SystemUser.class) && !existsLinks(SystemUserGroup.class)) {
			try {
				tm.transact(this::delete);
			} catch (Exception e) {
				return false;
			}
		}
		return true;
	}
}
